<!DOCTYPE html>
<html lang="en">
<head>
  <title>Mock yourself, not your tests | README.txt</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
  <link rel="stylesheet" media="(max-width: 750px)" href="/theme/css/mobile.css" type="text/css" />
  <link rel="stylesheet" href="/theme/css/github.css" type="text/css" />
  <link href="/images/favicon.ico" rel="icon" type="image/x-icon" />
  <link href="/rss.xml" type="application/atom+xml" rel="alternate" title="README.txt RSS Feed" />
  <meta name="description" content="Every mock is a smell, avoid them as much as you can.">
  <meta name="keywords" content="testing, python, mocks, rants">
  <meta name="author" content="hernantz">
</head>

<body>

  <aside class="sidebar">
    <a href="/"><img class="rounded-img" src="/images/avatar.png" height="75" width="75" /></a>

      <nav>
        <ul>
            <li><a href="http://twitter.com/hernantz">twitter</i></a></li>
            <li><a href="http://github.com/hernantz">github</i></a></li>
            <li><a href="http://last.fm/user/hernantz">last.fm</i></a></li>
            <li><a href="/talks.html">talks</a></li>
            <li><a href="/whoami.html">whoami</a></li>
            <li><a href="/">blog</a></li>
        </ul>
      </nav>

  </aside>
  <main>
        
<article class="column-right">
  <h1 class="main-title">Mock yourself, not your tests</h1>
  <summary>
    <p class="light">
      Published
on <time datetime="2015-07-27T00:00:00-03:00">Mon 27 July 2015</time>,       under <a href="http://hernantz.github.io/category/programming.html">Programming</a>,
      tagged with <a href="http://hernantz.github.io/tag/testing.html">testing</a>, <a href="http://hernantz.github.io/tag/python.html">python</a>, <a href="http://hernantz.github.io/tag/mocks.html">mocks</a> and <a href="http://hernantz.github.io/tag/rants.html">rants</a>.
    </p>
  </summary>
  <p><em>tl;dr</em>: While sometimes mocks are needed, they should not be the first tool 
you use to write tests. It is a pity to be mocking your code when you could
be writing meaningful tests at <em>almost</em> the same cost.</p>
<p><img alt="stower-titanic" src="/images/mock-yourself-not-your-tests.jpg" title="Der Untergang der Titanic by Willy StÃ¶wer" /></p>
<p>In this post I try to discourage the use of mocks when writing tests.
I'm not completely against them (I see their value) but it's that sometimes 
I feel like we abuse of them, just to make tests pass, feel comfortable of
seeing another green dot in our test suite and to release ourselves from the
burden of having to test our code.</p>
<h2 id="why-do-we-use-mocks-anyway">Why do we use mocks anyway?<a class="headerlink" href="#why-do-we-use-mocks-anyway" title="Permanent link">&para;</a></h2>
<p>Well, I'll name a few reasons that seem legit to me.</p>
<p>One reason to use mocks is to <strong>force a desired state</strong> for your test
and easily trigger side effects. Mocks facilitate a lot the testing of
corner cases.
Another reason is <strong>to gain speed</strong> by staying away from slow code, like
system calls, db, network calls, costly calculations, etc. Also it could be a
short path to <strong>increase code coverage</strong>. But probably the primary reason for
using mocks is to <strong>make a unit test more specific</strong>. Just testing exactly
one piece of code, and thus, avoiding having to test things that (hopefully)
are already tested.</p>
<h3 id="testing-with-mocks">Testing with mocks<a class="headerlink" href="#testing-with-mocks" title="Permanent link">&para;</a></h3>
<p>Let's see some example code:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Payment</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invoice_id</span><span class="p">,</span> <span class="n">credit_card</span><span class="p">):</span>
        <span class="c1"># more code here</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_amount</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">credit_card</span><span class="o">.</span><span class="n">has_credit</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">credit_card</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;processed&#39;</span>
</pre></div>


<p>As we can see, the <code>process()</code> method uses other objects (credit_card), called 
collaborators. If we were to write a <strong>unit test</strong> for this method, we would 
mock all its collaborators, so that we test the codepaths involved, and 
only caring that the function calls the collaborators, nothing more. We do this, 
because we are assuming that all the collaborators work and have their own unit 
tests.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mymodule</span> <span class="kn">import</span> <span class="n">Payment</span>
<span class="kn">from</span> <span class="nn">mock</span> <span class="kn">import</span> <span class="n">Mock</span>
<span class="kn">import</span> <span class="nn">unittest</span>


<span class="k">class</span> <span class="nc">PaymentTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@mock.patch.object</span><span class="p">(</span><span class="n">Payment</span><span class="p">,</span> <span class="s1">&#39;calculate_amount&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_process_cc_with_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculate_amount_mock</span><span class="p">):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
        <span class="n">calculate_amount_mock</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">cc</span><span class="o">.</span><span class="n">has_credit</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">payment</span> <span class="o">=</span> <span class="n">Payment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span>
        <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="n">cc</span><span class="o">.</span><span class="n">withdraw</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

    <span class="nd">@mock.patch.object</span><span class="p">(</span><span class="n">Payment</span><span class="p">,</span> <span class="s1">&#39;calculate_amount&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_process_cc_without_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculate_amount_mock</span><span class="p">):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
        <span class="n">cc</span><span class="o">.</span><span class="n">has_credit</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">payment</span> <span class="o">=</span> <span class="n">Payment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span>
        <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">withdraw</span><span class="o">.</span><span class="n">called</span><span class="p">)</span>
</pre></div>


<p>Now let's think for a moment if these tests we just wrote tell us, with a good
level of confidence, whether <code>process()</code> works or not. Or are we just asserting
that some methods are called in a specific order with specific parameters. This
feels almost like testing that the compiler/interpreter works!</p>
<blockquote>
<p><em>"We've fallen into a trap of testing that the code does what the code says 
it does, rather than testing functional behaviour we care about."</em></p>
<p><cite><a href="http://mauveweb.co.uk/posts/2014/09/every-mock-patch-is-a-little-smell.html">Every mock.patch() is a little smell</a></cite>. Daniel Pope.</p>
</blockquote>
<p>This kind of unit testing makes too many assumptions on how <code>process()</code> is
implemented. Tightly coupling your tests with mocks, causes refactors to be
painfull.  As soon as you change a detail of the implementation your tests will
<em>break</em> (which is not the same as to <em>fail</em>), with helpless tracebacks about
functions that were not called, or mocks that fail to be applied because some
method doesn't exist anymore, like:</p>
<div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;test.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">9</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">m</span><span class="o">.</span><span class="n">process_with_currency</span><span class="p">()</span>
  <span class="n">File</span> <span class="s2">&quot;/usr/local/lib/python2.7/site-packages/mock.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">65</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__getattr__</span>
    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Mock object has no attribute </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
<span class="ne">AttributeError</span><span class="p">:</span> <span class="n">Mock</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">&#39;some_old_method&#39;</span>
</pre></div>


<p>Another drawback I wanted to point out is that mocks tend to be too permissive, in 
the sense that they swallow errors that should occur because of a change in the 
API of the mocked object.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CreditCard</span><span class="p">():</span>
    <span class="c1"># ...</span>

    <span class="c1"># the old signature was: withdraw(self, amount)</span>
    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">currency</span><span class="p">):</span>
        <span class="c1"># ...</span>
</pre></div>


<p>If suddendly I decided to change the signature of the <code>withdraw()</code> method, to
charge the credit card with a specific currency, the mocked tests above would
still pass successfully. They will not tell you anymore whether you have
introduced a regression bug or not!</p>
<p>And even if you had a <em>real</em> test for the <code>withdraw()</code> method somewere, you
would still have to go change every test that assumed that this method worked and
did not fail.</p>
<p>Yes, I'm aware of the <code>autospec=True</code> param, that would restrict the mock to
just follow the object's api, making our tests a little bit less permissive.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mymodule</span> <span class="kn">import</span> <span class="n">Payment</span><span class="p">,</span> <span class="n">CreditCard</span>
<span class="kn">from</span> <span class="nn">mock</span> <span class="kn">import</span> <span class="n">Mock</span><span class="p">,</span> <span class="n">create_autospec</span>
<span class="kn">import</span> <span class="nn">unittest</span>


<span class="c1"># create a mock that mimics the real CreditCard object</span>
<span class="n">CreditCardMock</span> <span class="o">=</span> <span class="n">create_autospec</span><span class="p">(</span><span class="n">CreditCard</span><span class="p">,</span> <span class="n">spec_set</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PaymentTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@mock.patch.object</span><span class="p">(</span><span class="n">Payment</span><span class="p">,</span> <span class="s1">&#39;calculate_amount&#39;</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_process_cc_with_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculate_amount_mock</span><span class="p">):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">CreditCardMock</span><span class="p">()</span>
        <span class="n">calculate_amount_mock</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">cc</span><span class="o">.</span><span class="n">has_credit</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">payment</span> <span class="o">=</span> <span class="n">Payment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span>
        <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="n">cc</span><span class="o">.</span><span class="n">withdraw</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

    <span class="nd">@mock.patch.object</span><span class="p">(</span><span class="n">Payment</span><span class="p">,</span> <span class="s1">&#39;calculate_amount&#39;</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_process_cc_without_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculate_amount_mock</span><span class="p">):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">CreditCardMock</span><span class="p">()</span>
        <span class="n">cc</span><span class="o">.</span><span class="n">has_credit</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">payment</span> <span class="o">=</span> <span class="n">Payment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span>
        <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">withdraw</span><span class="o">.</span><span class="n">called</span><span class="p">)</span>
</pre></div>


<p>Or we could have gone a little bit further, and inject a double to our
<code>process()</code> function, for example:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FakeCreditCard</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace our CreditCard with a double to avoid hitting the db or</span>
<span class="sd">    3rd party services (if any).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amount</span> <span class="o">=</span> <span class="n">amount</span>

    <span class="k">def</span> <span class="nf">has_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amount</span> <span class="o">-</span> <span class="n">amount</span>
</pre></div>


<p>This is also an interesting strategy, but, now you'll have to be maintaining
this double by hand, every time you real object is updated.</p>
<p>Let's try a completely different approach and see if we can do any better.</p>
<h3 id="testing-without-mocks">Testing without mocks<a class="headerlink" href="#testing-without-mocks" title="Permanent link">&para;</a></h3>
<p>Now, how would I test this, without mocks?</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mymodule</span> <span class="kn">import</span> <span class="n">Payment</span> 
<span class="kn">from</span> <span class="nn">myfactories</span> <span class="kn">import</span> <span class="n">CreditCardFactory</span><span class="p">,</span> <span class="n">InvoiceFactory</span>
<span class="kn">import</span> <span class="nn">unittest</span>


<span class="k">class</span> <span class="nc">PaymentTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_process_cc_with_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">InvoiceFactory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">CreditCardFactory</span><span class="p">(</span><span class="n">balance</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">payment</span> <span class="o">=</span> <span class="n">Payment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span>
        <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">balance</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_process_cc_without_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">InvoiceFactory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">CreditCardFactory</span><span class="p">(</span><span class="n">balance</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">payment</span> <span class="o">=</span> <span class="n">Payment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span>
        <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">balance</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>Comparing the test above, with the one that uses mocks, we can see that it has 
almost the same amount of code, but this test is not bound to the implementation, 
it is still deterministic, plus it tests goals in an automated way, similar to 
the manual check I would do to trust that the <code>process()</code> method works.</p>
<p>We have used two techniques here that helped us get way from mocks.</p>
<p>The first technique was to start testing how collaborators interact between
each other inside <code>process()</code>. These type of tests are called <strong>integration
tests</strong>, that test larger units of your code, with real components. This also 
helped reducing the chance of bugs that sneak away when you test units in 
isolation.</p>
<p><em>Side note</em>: Keep a reasonable amount of code under your tests. While writing
tests for very small units of code might be adding noise to your test suite,
there won't be too much value in testing a huge portion of your code either.</p>
<p>The second technique consisted in using factories. I mention this, because we
(lazy developers) often use mocks as a quick solution to creating the complex
conditions.</p>
<p>What's important is that factories <strong>build real objects</strong> for you in a
declarative and straighforward way, which let's you focus on the bits of data
you need to setup your test and leave the rest for the factory to implement.</p>
<h2 id="in-the-quest-for-real-mocks">In the quest for <em>real mocks</em><a class="headerlink" href="#in-the-quest-for-real-mocks" title="Permanent link">&para;</a></h2>
<p>Alright! This is looking better, but does this mean that we can get rid of
mocks once for all? Nope.</p>
<p>There are cases where it really makes sense to use mocks. I'll show you a couple
of examples that, in my opinion, could serve as inspiration to use them
successfully and write better tests. These mocks are: </p>
<ul>
<li><strong>Agnostic</strong>: the details of your code change, but your mocks continue to work.</li>
<li><strong>Swappable</strong>: you can easily turn them on/off or switch to them on the fly.</li>
<li><strong>Precise</strong>: they stub only the sensible parts of the real object.</li>
<li><strong>Verified</strong>: the interfaces of such mock are carefully maintained and mimic the
  real object.</li>
</ul>
<h3 id="example-1-a-verified-mock">Example 1: A verified mock<a class="headerlink" href="#example-1-a-verified-mock" title="Permanent link">&para;</a></h3>
<p>Django gives us an in-memory mailbox that captures all outgoing emails. What's 
interesting is that it sets up this dummy double  <strong>by default</strong> when you 
inherit from <code>TestCase</code>, so writing these kind of tests becomes really easy.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mymodule</span> <span class="kn">import</span> <span class="n">Payment</span>
<span class="c1"># ...</span>
<span class="kn">from</span> <span class="nn">django.core</span> <span class="kn">import</span> <span class="n">mail</span>
<span class="kn">from</span> <span class="nn">django.test</span> <span class="kn">import</span> <span class="n">TestCase</span>


<span class="k">class</span> <span class="nc">PaymentTestCase</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_process_cc_with_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this factory will create an Invoice and a User associated to </span>
        <span class="c1"># it, with the specified email</span>
        <span class="n">InvoiceFactory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">user__email</span><span class="o">=</span><span class="s1">&#39;foo@bar.com&#39;</span><span class="p">)</span>
        <span class="c1"># ... more code </span>

        <span class="c1"># Test that payment receipt email has been sent.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mail</span><span class="o">.</span><span class="n">outbox</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">mail</span><span class="o">.</span><span class="n">outbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;foo@bar.com&#39;</span><span class="p">])</span>
</pre></div>


<p>Now, you might be thinking that I'm contradicting myself with this example,
since no email is really being sent.</p>
<p>That is a valid concern, but, provided that in my code, I interact with an
abstraction a framework gives us for sending emails, and that behind the scenes
it is replacing the real email machinery with a double that mimics that
behaviour, I believe I can still make assertions about my code that are <em>good
enough</em> (even though no mail is sent). That framework is responsible for
providing us with a good <em>verified</em> stub.</p>
<h3 id="example-2-an-agnostic-mock">Example 2: An agnostic mock<a class="headerlink" href="#example-2-an-agnostic-mock" title="Permanent link">&para;</a></h3>
<p>Say for example that you need to hit a 3rd party API that you don't own, that
probably has throttle limitations, no sandbox/testing ground, you cannot setup
and run it locally, or all these together. Doing live testing is not really an
option. But if you use something like <a href="https://github.com/kevin1024/vcrpy">vrc.py</a>, then you profit from testing
against real requests/responses that are recorded, so that next time you run the
test suite it runs under safe and repeatable conditions, without hitting the net.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mymodule</span> <span class="kn">import</span> <span class="n">Payment</span> 
<span class="c1"># ...</span>
<span class="kn">import</span> <span class="nn">vcr</span>


<span class="k">class</span> <span class="nc">PaymentTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@vcr.use_cassette</span><span class="p">(</span><span class="s1">&#39;stripe_responses/cc_with_credit.yaml&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_process_cc_with_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... more code</span>

    <span class="nd">@vcr.use_cassette</span><span class="p">(</span><span class="s1">&#39;stripe_responses/cc_without_credit.yaml&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_process_cc_without_credit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... more code </span>
</pre></div>


<p>If the 3rd party API changes, you don't have to do anything but delete the
recorded responses, and your test will do all the work for you, updating the
test cases with the new responses.
Should you need more control over a certain response that is not easy to 
reproduce, (like a 500 error response), you can achieve that with <a href="https://github.com/gabrielfalcao/HTTPretty">httpretty</a>.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">httpretty</span>

<span class="k">class</span> <span class="nc">PaymentTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@httpretty.activate</span>
    <span class="k">def</span> <span class="nf">test_process_handles_failure_from_stripe</span><span class="p">():</span>
        <span class="n">httpretty</span><span class="o">.</span><span class="n">register_uri</span><span class="p">(</span><span class="n">httpretty</span><span class="o">.</span><span class="n">GET</span><span class="p">,</span> <span class="s1">&#39;https://api.stripe.com&#39;</span><span class="p">,</span>
                               <span class="n">body</span><span class="o">=</span><span class="s1">&#39;{&quot;success&quot;: false}&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                               <span class="n">content_type</span><span class="o">=</span><span class="s1">&#39;text/json&#39;</span><span class="p">)</span>
        <span class="c1"># ... more code</span>
        <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">payment</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="s1">&#39;failed&#39;</span><span class="p">)</span>
</pre></div>


<p>I consider httpretty and vcr.py to be good examples of <em>agnostic</em> mocks, since
they can be used no matter which network library you are using.</p>
<h3 id="example-3-a-precise-mock">Example 3: A precise mock<a class="headerlink" href="#example-3-a-precise-mock" title="Permanent link">&para;</a></h3>
<p>When you need to test code that deals with dates, mocks will be very handy
too. Let's see an example.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="k">class</span> <span class="nc">Payment</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... more code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>


<p>To test this, you would have to write tests that have almost the same code you
are trying to test, and, depending on how precise the dates you are handling
are, <strong>your tests could fail from time to time</strong>, ie: some tests might fail
when you run them at midnight, or fail because of a difference of one
millisecond.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PaymentTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_payment_date_is_saved</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... more code</span>
        <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">payment</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>  <span class="c1"># this won&#39;t work</span>
</pre></div>


<p>Now, when we test using the <a href="https://github.com/spulec/freezegun">freezegun</a> module, we can ditch the <em>mock
everything</em> strategy.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">freezegun</span> <span class="kn">import</span> <span class="n">freeze_time</span>

<span class="k">class</span> <span class="nc">PaymentTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_payment_date_is_saved</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... more code</span>
        <span class="k">with</span> <span class="n">freeze_time</span><span class="p">(</span><span class="s1">&#39;2012-01-01&#39;</span><span class="p">):</span>
            <span class="n">payment</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">payment</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">),</span> <span class="s1">&#39;2012-01-02&#39;</span><span class="p">)</span>
</pre></div>


<p>You can see how we avoided mocking <code>datetime.now()</code> and we how we can even use
<code>strftime()</code> in our tests. Because freezegun is <em>precise</em>, it only mocks
datetime functions that are used to obtain the current time, and leaves
everything else untouched. We made time behave deterministically using a nice
declarative API, that doesn't get in our way. We can even calculate the payment
date using other libraries.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">arrow</span>

<span class="k">class</span> <span class="nc">Payment</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... more code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>  <span class="c1"># Our test still passes :)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>


<h2 id="need-for-speed">Need for speed<a class="headerlink" href="#need-for-speed" title="Permanent link">&para;</a></h2>
<p>I mentioned that using mocks was a legit excuse for speeding your tests, and
staying away from slow parts like the database. Well if you used an ORM and your
data structures are pretty standard, then you may be able to <a href="http://www.machinalis.com/blog/optimizing-your-tests-in-django/">switch to an
in-memory sqlite database</a> just to run your tests.</p>
<p>Another possibility that's worth exploring, but I haven't tried myself though,
is to <a href="https://gist.github.com/zekefast/07fa5434afcd0ba77f9b" title="Run postgresql in a ram disk">mount the database</a> in a <code>tmpfs</code> filesystem, or combine that with a
<a href="https://github.com/gentics/docker-tmpfs-mysql" title="Docker tmpfs mysql">custom docker build</a> to gain speed, but at the same time, run the tests
against the db engine you use in production, and thus, gain also reliability.</p>
<p>In case you don't want to mess with custom setups for testing, there are some
easy tricks to speed your tests like running them in parallel:</p>
<div class="highlight"><pre><span></span>$ nosetests --processes<span class="o">=</span>NUM
</pre></div>


<p>provided that your tests <a href="http://nose.readthedocs.org/en/latest/plugins/multiprocess.html#beware">can run concurrently</a> and are IO bound, or simply
<a href="https://twitter.com/df07/status/607562584401821696">throw hardware at the problem</a> with more RAM, a more powerful CPU or an
SSD.</p>
<h2 id="in-conclusion">In conclusion<a class="headerlink" href="#in-conclusion" title="Permanent link">&para;</a></h2>
<ul>
<li>Integration tests are one honking great idea, let's do more of those. Don't 
  rely exclusively in unit tests, test goals.</li>
<li>Use factories to reduce boilerplate of tests setup and asserting a known state
  before they run.</li>
<li>Avoid using mocks as much as you can. There's a good chance you'll be testing 
  what the code does, not what it should do.</li>
<li>In times of need, apply well maintained global mocks, the closest possible to 
  the danger zone.</li>
</ul>
<p>Mock yourself not your tests :P</p>
</article>

      <footer class="column-right light">
        <nav><a href="/">Home</a> - <a href="/archives.html">Archives</a> - <a href="/categories.html">Categories</a> - <a href="/tags.html">Tags</a> - <a href="/rss.xml">RSS</a> - <a href="https://creativecommons.org/licenses/by/4.0/">License</a> | README.txt</nav>
      </footer>
  </main>
</body>
</html>