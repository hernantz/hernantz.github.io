<!DOCTYPE html>
<html lang="en">
<head>
  <title>Taming Backbone Views: Part 1 | README.txt</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
  <link rel="stylesheet" href="/theme/css/github.css" type="text/css" />
  <link href="/images/favicon.ico" rel="icon" type="image/x-icon" />
  <link href="/rss.xml" type="application/atom+xml" rel="alternate" title="README.txt RSS Feed" />
  <meta name="description" content="Some bro tips I learned the hard way when dealing with Backbone views">
  <meta name="keywords" content="backbonejs, best-practices, javascript">
  <meta name="author" content="hernantz">
</head>

<body>

  <aside class="sidebar">
    <a href="/"><img class="rounded-img" src="/images/avatar.png" height="75" width="75" /></a>

      <nav>
        <ul>
            <li><a href="http://twitter.com/hernantz">twitter</i></a></li>
            <li><a href="http://github.com/hernantz">github</i></a></li>
            <li><a href="/whoami.html">whoami</a></li>
            <li><a href="/">blog</a></li>
        </ul>
      </nav>

  </aside>

        
<article class="column-right">
  <h1 class="main-title">Taming Backbone Views: Part 1</h1>
  <summary>
    <p class="light">
      Published
on <time datetime="2014-08-25T19:42:00-03:00">Mon 25 August 2014</time>,       under <a href="http://hernantz.github.io/category/programming.html">Programming</a>,
      tagged with <a href="http://hernantz.github.io/tag/backbonejs.html">backbonejs</a>, <a href="http://hernantz.github.io/tag/best-practices.html">best-practices</a> and <a href="http://hernantz.github.io/tag/javascript.html">javascript</a>.
    </p>
  </summary>
  <p>It often seems to me that Backbone developers sometimes do not trust that the
<code>view.el</code> property be present when needed, eg: when rendering the view.</p>
<h1 id="el-you-there">"el", you there?<a class="headerlink" href="#el-you-there" title="Permanent link">&para;</a></h1>
<p>But the true story is that Backbone ensures this element is up and running 
for us, since the view construction.  These snippets where taken directly from 
Backbone's source and show a bit of two methods that are ment to be used internally 
by Backbone when instantiating a new View:</p>
<div class="highlight"><pre><span></span><span class="nx">_ensureElement</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="cm">/* check if this view was not initialize </span>
<span class="cm">         with an {el: &#39;.selector&#39;} option  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">)</span> <span class="p">{</span>  
        <span class="cm">/* ... after constructing an `attrs` object with</span>
<span class="cm">           the param options for `id`, `className` and `attributes` </span>
<span class="cm">           create the element specified by `tagName` */</span>
        <span class="kd">var</span> <span class="nx">$el</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="nx">_</span><span class="p">.</span><span class="nx">result</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;tagName&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="nx">attrs</span><span class="p">);</span>

        <span class="c1">// now attach this.$el and this.el properties</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setElement</span><span class="p">(</span><span class="nx">$el</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
      <span class="p">}</span>     
      <span class="c1">// ... more here omited for brevity</span>
<span class="p">}</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="nx">delegateEvents</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">events</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">undelegateEvents</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">events</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="c1">// the the context of the callback to `this`</span>
        <span class="nx">method</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="c1">// set a unique namespace to be easyly unbindable later</span>
        <span class="nx">eventName</span> <span class="o">+=</span> <span class="s1">&#39;.delegateEvents&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">cid</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="c1">// lazyly listen to the event</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">$el</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="nx">eventName</span><span class="p">,</span> <span class="nx">selector</span><span class="p">,</span> <span class="nx">method</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p><code>_ensureElement</code> will construct our element a attach it to the view instance and 
<code>delegateEvents()</code> will lazyly bind DOM events for that element, and all this without worring about 
the element having to be inserted into the DOM to interact with it's view.</p>
<p>Backbone being very flexible, lets us override the <code>el</code> property with some other element.
We can pass a jquery object or simply a selector and backbone will handle it.</p>
<div class="highlight"><pre><span></span><span class="c1">// Backbone also lets us override the `el` with either of these ways </span>
<span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">({</span><span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#selector&#39;</span><span class="p">});</span>
<span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">({</span><span class="nx">el</span><span class="o">:</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#selector&#39;</span><span class="p">)});</span>
</pre></div>


<p>In the example above, we need to make sure that, at the moment that View is declared or
executed, the <code>#selector</code> exists in the DOM. Otherwise we won't have any html to get from 
the View. So, continueing with the previous example and with a little help from jquery we 
can be sure that <code>#selector</code> element can be reached.</p>
<div class="highlight"><pre><span></span><span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">({</span><span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#selector&#39;</span><span class="p">});</span>
<span class="p">});</span>
</pre></div>


<p>But even if we make sure of that, <strong>is it a good practice to pass around the <code>el</code> object to the
View?</strong></p>
<p>I'll try to cover the pros and cons of dealing with an encapsulated <code>el</code> property vs passing it 
directly to the view in the following post.</p>
<p>it uses event delegation for the events hash, so as long as the element eventually exists</p>
<p><domino14> if i define an event in a Backbone view, like in events { 'click #btn': 'someFunction'}  does the button have to exist when the view is created?
<domino14> i was under the impression that it didn't
<domino14> yet my "someFunction" isn't executing when i click the button...
<corbanb> yes it has to be in the scope of that view
<domino14> ive had plenty of times where render() creates the buttons that are defined in events {}
<domino14> and the click works
<domino14> render would presumably be created after</p>
<h1 id="react-without-react">React without react<a class="headerlink" href="#react-without-react" title="Permanent link">&para;</a></h1>
<p>Understanding the principles, implementing with Backbone
USE swig template engine to share templates and do server side rendering
Mostrar una lib donde se hace rerender sin el shadow dom
Mostrar como usando los mismos templates se puede hacer renderizado del lado del server.
Mostrar como hacer una "ui loading" que empieza a renderizarse en el server y termina en el frontend</p>
</article>

  <footer class="column-right light">
    <nav><a href="/">Home</a> - <a href="/archives.html">Archives</a> - <a href="/categories.html">Categories</a> - <a href="/tags.html">Tags</a> - <a href="/rss.xml">RSS</a> | README.txt (© 2016)</nav>
    <p></p>
  </footer>

</body>
</html>