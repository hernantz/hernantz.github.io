<!DOCTYPE html>
<html lang="en">
<head>
  <title>One config.py to config them all | README.txt</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
  <link rel="stylesheet" media="(max-width: 750px)" href="/theme/css/mobile.css" type="text/css" />
  <link rel="stylesheet" href="/theme/css/github.css" type="text/css" />
  <link href="/images/favicon.ico" rel="icon" type="image/x-icon" />
  <link href="/rss.xml" type="application/atom+xml" rel="alternate" title="README.txt RSS Feed" />
  <meta name="description" content="How to do configuration management.">
  <meta name="keywords" content="python, configuration, architecture">
  <meta name="author" content="hernantz">
</head>

<body>

  <aside class="sidebar">
    <a href="/"><img class="rounded-img" src="/images/avatar.png" height="75" width="75" /></a>

      <nav>
        <ul>
            <li><a href="http://twitter.com/hernantz">twitter</i></a></li>
            <li><a href="http://github.com/hernantz">github</i></a></li>
            <li><a href="http://last.fm/user/hernantz">last.fm</i></a></li>
            <li><a href="/whoami.html">whoami</a></li>
            <li><a href="/">blog</a></li>
        </ul>
      </nav>

  </aside>
  <main>
        
<article class="column-right">
  <h1 class="main-title">One config.py to config them all</h1>
  <summary>
    <p class="light">
      Published
on <time datetime="2018-05-05T00:00:00-03:00">Sat 05 May 2018</time>,       under <a href="../category/programming.html">Programming</a>,
      tagged with <a href="../tag/python.html">python</a>, <a href="../tag/configuration.html">configuration</a> and <a href="../tag/architecture.html">architecture</a>.
    </p>
  </summary>
  <p><img alt="configuration management" src="/images/configuration.png" title="Configuration management" /></p>
<p>differences in configuring a library vs a project or app</p>
<p>Show the problem with <code>local_settings.py</code> -&gt; custom code that imports *
Why is better for config to be static
you shouldn't need to learn python to configure your program</p>
<p>first come, first served</p>
<p>Discoverability of settings
1. cli args
2. environment variables
3. Config files in different directories
4. Hardcoded constants</p>
<p>Introducing prettyconf</p>
<p>How to reload program when config changes
Systemd?</p>
<p>settings stored in a db
how to dynamically update settings (process signals?)
trick of using <code>settings.py.template</code></p>
<p><zoredache> hernantz: maybe make an example vars file or something that is in the vcs, then instruct the devs to copy+populate the template to a name that is excluded by a gitignore?
Problem with this is that from time to time settings names might change, and when switching to that branch you have to manually change settings file that is not versioned.
Si las configs son como una base de datos en un archivo, por ahi puede existir un modelo que las represente y tener un sistema de migraciones entre schemas.</p>
<p>How to manage secrets for tests (should not be secrets, because testing should not have any dangerous side effect) the same applies for continuous integration toolks.</p>
<p>1 x entorno
separar datos del codigo (config input vs code that uses that input)
clases para herencia vs import *
run env vs test config (solo cambian los datos)
manage.py params?</p>
<p>Hernan's proposal
I'm going to try to explain my proposal by first exposing the problem. I invite everyone to do the same and/or comment inline any comments.</p>
<p>Project (app) vs Library
There is a difference between configuring a library vs configuring a project.
A library is meant to be a reusable piece of code that should not make assumptions on where and how it is going to be used.
For this reason a library should be only configured through code, and never require env variables or configuration files to exist in order to be used.
A project might use many libraries that require different configs (a database connector, s3 storage, etc). So it is in charge of gathering required config and using these libraries.
For example: 
If a library that is a database connector gathered it's own configuration from the environment or a file, it would be complicated for an app reuse that library to connect to different databases.
In this case, it is the app's responsibility to gather the connection settings and use the library to connect to two separate databases, because the app knows what it needs, not the library.</p>
<p>How to configure a project (or application)
It is important to provide a clear separation of configuration and code (https://12factor.net/config).
This is because config varies substantially across deploys and executions, code does not.
The same code can be run inside a container or in a regular machine. It can be executed in production or in testing environments.
Environment variables are important. But we have to be careful on how we use them.
Why not use environment variables directly?
There is a common pattern to read configurations in environment variable that look similar to the code below:</p>
<p>if os.environ.get("DEBUG", False):
    print(True)
else:
    print(False)</p>
<p>But this code have some issues:</p>
<p>if ENV VAR DEBUG=False this code will print True because os.environ.get("DEBUG", False) will return an string ‘False’ instead of a boolean False. And a non-empty string has a True boolean value. 
We can’t (dis|en)able debug with ENV VAR DEBUG=yes|no, DEBUG=1|0, DEBUG=True|False.
We need to start casting/parsing everywhere.
If we want to use this configuration during development we need to define this ENV VAR all the time. We can’t define this setting in a configuration file that will be used if DEBUG envvar is not defined.
We also need to consolidate configuration in a single source of truth to avoid having config management scattered all over the codebase.
This is because a well designed application needs to allow different ways to be configured.</p>
<p>App's hardcoded defaults &lt; config files &lt; ENV VARS &lt; Direct CLI args.
And you should have all this configuration management handled before the program starts, to avoid parsing files, or passing CLI args everywhere.
So ideally we would have a single settings.py file where configuration is gathered/parsed/processed. The app imports that config module and distributes it to all the different libraries it is using.</p>
<p>Config files are very convenient since they can be version-controlled, can be put into templates by Config Management/Orchestration tools and come handy when developing. 
It is also possible to put ENV VARS into a file that gets loaded before the program starts. The convention is to put configuration in ".env" files. Many tools that manage processes/containers, like docker-compose and systemd, have support for loading them.</p>
<p>Installer
Code needs to be packaged (built), distributed, installed, executed (https://12factor.net/build-release-run).
These are all steps that make use of external tools that are not part of the codebase and should be replaceable.
An app could be packaged for Ubuntu or Windows differently, can be installed manually or put in a container.
For this reason, code should be as agnostic of these steps as possible and delegate that to another actor called "Installer/Builder".
This new actor can be one or many tools combined, for example docker-compose, yum, gcc, ansible, etc.
The installer actor is the one that knows how to bind code with the right configuration it needs and how to do it (through env vars or files or cli args or all of them). Because it knows the configuration it needs to inject into the project, it makes a good candidate to manage configuration.
It can do so by having configuration templates for files or settings that will be injected into the environment, it knows about keeping secret/sensistive information protected, etc.</p>
<p>The dev(ops) flow has two clearly distinct realms:</p>
<div class="highlight"><pre><span></span>+-------+             +-------+          +--------+         +-------+         +-------+
|       |             |       |          |        |         |       |         |       |
| code  +------------&gt;| build +---------&gt;|        |&lt;--------+service|&lt;--------+ conf  +
|       |             |       |          |        |         |       |         |       |
+-------+             +-------+          |        |         +-------+         +-------+
                                         |        |
                      +-------+          |        |         +-------+         +-------+
                      |       |          |        |         |       |         |       |
                      | conf  +---------&gt;|release |&lt;--------+service|&lt;--------+ conf  +
                      |       |          |        |         |       |         |       |
                      +-------+          |        |         +-------+         +-------+
                                         |        |
                      +-------+          |        |         +-------+         +-------+
                      |       |          |        |         |       |         |       |
                      | deps  +---------&gt;|        |&lt;--------+service|&lt;--------+ conf  +
                      |       |          |        |         |       |         |       |
                      +-------+          +--------+         +-------          +-------+

+---------------------+---------------------------------------------------------------+
|       code realm    |                   Devops/CM/Orchestraion realm                |
+---------------------+---------------------------------------------------------------+
</pre></div>


<p>If you use different tools when developing and when deploying, all these scripts and templates will start to increse in number. When that moment comes, there will be the temptation to delegate all this responsability to the app to "autoconfigure and install itself".
Sometimes an app not only needs to be configured, but it might need other services to be running, so you'll have to replace an orchestration tool and a supervisor (https://12factor.net/backing-services).
This basically means that you will be replacing specialiced tools with battle-tested ready-made solutions with your own implementation. More code, mode problems.
Ideally, a project should support one build tool and use it for development and production. For example: docker everywhere.</p>
<p>The important thing to note here is that the application's code should not install dependencies or start services or export variables to the environment because mongo needs them.</p>
<p>Proposed architechture:
Always use a single config.py file and load it before starting the program. Use prettyconf since it follows this architecture (or will soon: https://github.com/osantana/prettyconf/issues/18).
Configuration for other services should be handled separately.
Keep in mind what belongs to which realm when writing code/scripts. Everything can live in the same repo, but at least they will be in different folders (src and ops, for example).
Consolidate a very similar set of tools for dev and production envs. Containers are gaining popularity everywhere, we can either use docker/ansible-container for both realms.
Ansible container: https://github.com/ansible/ansible-container
Docker: https://www.docker.com/</p>
<p>La base de datos tmb es una forma de configuracion para un programa.
Por ejemplo las config de los juegos sobre la resolucion, sensibilidad del mouse, etc.
O feature flags, esto es configuracion dinamica, vs configuracion estatica de prettyconf.</p>
<p>https://12factor.net/config
https://en.wikipedia.org/wiki/Windows_Registry</p>
<h2 id="managing-config-changes">Managing config changes<a class="headerlink" href="#managing-config-changes" title="Permanent link">&para;</a></h2>
<p>consult template -&gt; places template -&gt; emits reload signal -&gt; program picks up new config
reload config signal (reload(config))
Database based configuration can bring the chickend and egg problem, for a large system.
Sqlite can be usefull for some programs, to store configuration provided by a non technical user (like screen resolution for counter strike).
But for a program to scale in a cluster, it is better not to force any db/connector/table/etc, by just issuing a file and and accepting reload.</p>
</article>

      <footer class="column-right light">
        <nav><a href="/">Home</a> - <a href="/archives.html">Archives</a> - <a href="/categories.html">Categories</a> - <a href="/tags.html">Tags</a> - <a href="/rss.xml">RSS</a> - <a href="https://creativecommons.org/licenses/by/4.0/">License</a> | README.txt</nav>
      </footer>
  </main>
</body>
</html>