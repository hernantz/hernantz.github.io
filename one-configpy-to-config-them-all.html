<!DOCTYPE html>
<html lang="en">
<head>
  <title>One config.py to config them all | README.txt</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
  <link rel="stylesheet" media="(max-width: 750px)" href="/theme/css/mobile.css" type="text/css" />
  <link rel="stylesheet" href="/theme/css/github.css" type="text/css" />
  <link href="/images/favicon.ico" rel="icon" type="image/x-icon" />
  <link href="/rss.xml" type="application/atom+xml" rel="alternate" title="README.txt RSS Feed" />
  <meta name="description" content="How to do configuration management.">
  <meta name="keywords" content="python, best-practices, configuration, architecture, tools">
  <meta name="author" content="hernantz">
</head>

<body>

  <aside class="sidebar">
    <a href="/"><img class="rounded-img" src="/images/avatar.png" height="75" width="75" /></a>

      <nav>
        <ul>
            <li><a href="http://twitter.com/hernantz">twitter</i></a></li>
            <li><a href="http://github.com/hernantz">github</i></a></li>
            <li><a href="http://last.fm/user/hernantz">last.fm</i></a></li>
            <li><a href="/whoami.html">whoami</a></li>
            <li><a href="/">blog</a></li>
        </ul>
      </nav>

  </aside>
  <main>
        
<article class="column-right">
  <h1 class="main-title">One config.py to config them all</h1>
  <summary>
    <p class="light">
      Published
on <time datetime="2018-05-11T00:00:00-03:00">Fri 11 May 2018</time>,       under <a href="http://hernantz.github.io/category/programming.html">Programming</a>,
      tagged with <a href="http://hernantz.github.io/tag/python.html">python</a>, <a href="http://hernantz.github.io/tag/best-practices.html">best-practices</a>, <a href="http://hernantz.github.io/tag/configuration.html">configuration</a>, <a href="http://hernantz.github.io/tag/architecture.html">architecture</a> and <a href="http://hernantz.github.io/tag/tools.html">tools</a>.
    </p>
  </summary>
  <p><img alt="configuration management" src="/images/configuration.png" title="Configuration management" /></p>
<p>Configuration allows us to modify the behavior of our software based on a
number of settings, with the goal of providing more flexibility to the users of
such software.</p>
<p>Configuration management is an important aspect of the architecture of any
system. But it is sometimes overlooked.</p>
<p>The purpose of this post is to explore a proposed solution for proper config
management in general, and for a python app in particular.</p>
<h2 id="types-of-configuration">Types of configuration<a class="headerlink" href="#types-of-configuration" title="Permanent link">&para;</a></h2>
<p>Hold on a moment. Configuration understood as a mechanism of altering the state
and behavior of a program can be very broad.</p>
<p>We are interested in the <em>deterministic configuration</em> that presets the state
of a program, without having to interact with it, like static config files or
environment variables.</p>
<p>On the other hand, there's the <em>runtime configuration</em>, which happens when the
user interacts with the system. User preferences are a typical example of this
kind.</p>
<p>It may not always apply, but a general rule of thumb is to separate config by
how it affects code: Code that varies depending on where it is run (static),
as oposed on how it is used (runtime).</p>
<p>We make the distinction because the later is not very general and is up to the
developer to decide how to manage it. If it is a desktop app, a file or a
sqlite database might suffice, but for a cloud app, maybe a distributed
key-value store is needed.</p>
<h2 id="project-app-vs-library">Project (app) vs Library<a class="headerlink" href="#project-app-vs-library" title="Permanent link">&para;</a></h2>
<p>The first thing to determine is the type of software that needs to be
configured. There is a difference between configuring a library vs configuring
a project.</p>
<p>Lets see an example of how <code>sqlalchemy</code>, a database toolkit library, provides
us with the needed building blocks for us to use as we please.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;person&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">250</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># Engine used to store data</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///sqlalchemy_example.db&#39;</span><span class="p">)</span>

<span class="c1"># Create all tables in the engine.</span>
<span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</pre></div>


<p>A library is meant to be a reusable piece of code that should not make
assumptions on where and how it is going to be used. </p>
<p>Imagine if <code>sqlalchemy</code> gathered it's engine configuration from an environment
variable <code>SQLALCHEMY_ENGINE=sqlite:///sqlalchemy_example.db</code> or a file in
<code>/etc/sqlalchemy/engine.cfg</code>. It would be complicated for an app reuse that
library to connect to different databases.</p>
<p>For this reason a library should be only configured through code, and never
require env variables or configuration files to exist in order to be used. </p>
<p>A project might use many libraries that require different configs (a database
connector, s3 storage, etc). So it is in charge of gathering required config
and using these libraries.</p>
<p>In this case, it is the app's responsibility to gather the connection settings
and use the library to connect to two separate databases, because the app knows
what it needs, not the library.</p>
<h2 id="how-to-configure-a-project-or-application">How to configure a project (or application)<a class="headerlink" href="#how-to-configure-a-project-or-application" title="Permanent link">&para;</a></h2>
<p>It is important to provide a clear separation of configuration and code. This
is because config varies substantially across deploys and executions, code does
not. The same code can be run inside a container or in a regular machine, it
can be executed in production or in testing environments.</p>
<h3 id="where-to-get-configuration-from">Where to get configuration from<a class="headerlink" href="#where-to-get-configuration-from" title="Permanent link">&para;</a></h3>
<p>Configuration for a project might come from different sources, like <code>.ini</code>
files, envirionment variables, etc.</p>
<p>For example, there is a common pattern to read configurations in <a href="https://12factor.net/config" title="The twelve-factor app | config">environment
variables</a> that look similar to the code below:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DEBUG&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</pre></div>


<p>Why is getting config variables directly a bad idea?</p>
<p>If env var <code>DEBUG=False</code> this code will print <code>True</code> because
<code>os.environ.get("DEBUG", False)</code> will return an string <code>‘False’</code> instead of a
boolean <code>False</code>. And a non-empty string has a <code>True</code> boolean value. We can't
(dis|en)able debug with env var <code>DEBUG=yes|no</code>, <code>DEBUG=1|0</code>,
<code>DEBUG=True|False</code>. We need to start casting/parsing everywhere.</p>
<p>If we want to use this configuration during development we need to define this
env var all the time. We can't define this setting in a configuration file that
will be used if <code>DEBUG</code> envvar is not defined.</p>
<p>Well designed applications allow different ways to be configured. A proper
settings-discoverability chain goes as follows:</p>
<ol>
<li>CLI args.</li>
<li>Environment variables.</li>
<li>Config files in different directories, that also imply some hierarchy. For
   example: config files in <code>/etc/myapp/settings.ini</code> are applied system-wide,
   while <code>~/.config/myapp/settings.ini</code> take precedence and are user-specific.</li>
<li>Hardcoded constants.</li>
</ol>
<p>The rises the need to consolidate configuration in a single source of truth to
avoid having config management scattered all over the codebase. </p>
<p>All this configuration management should be handled before the program starts,
to avoid parsing files, or passing CLI args everywhere. So ideally we would
have a single <code>config.py</code> file where settings are gathered, parsed and
processed. The app imports that config module and distributes it to all the
different libraries it is using.</p>
<p>An example startup script for your app could be:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">gather_conf</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">conf</span> <span class="o">=</span> <span class="n">gather_conf</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/app/config_file&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="n">main</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>  <span class="c1"># conf is a dict of settings</span>
</pre></div>


<h3 id="a-single-executable-file">A single executable file<a class="headerlink" href="#a-single-executable-file" title="Permanent link">&para;</a></h3>
<p>Another anti-pattern to be aware of is having as many configuration modules as
environment there are:  <code>dev_settings.py</code>, <code>staging_settings.py</code>,
<code>local_settings.py</code>, etc, and including different logic on them.</p>
<p>A very simple example of custom logic is:</p>
<div class="highlight"><pre><span></span><span class="c1"># base_settings.py</span>
<span class="n">PLUGINS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">]</span>


<span class="c1"># dev_settings.py</span>
<span class="kn">from</span> <span class="nn">base_settings</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">PLUGINS</span> <span class="o">=</span> <span class="n">PLUGINS</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;baz&#39;</span><span class="p">]</span>
</pre></div>


<p>Should be a single <code>settings.py</code>:</p>
<div class="highlight"><pre><span></span><span class="c1"># settings.py</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">(</span><span class="s1">&#39;config.ini&#39;</span><span class="p">)</span>

<span class="c1"># this is what the app uses</span>
<span class="n">PLUGINS</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;BASE_PLUGINS&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;EXTRA_PLUGINS&#39;</span><span class="p">]</span>
</pre></div>


<p>Which gets its config from a local ini file for example:</p>
<div class="highlight"><pre><span></span><span class="c1"># /etc/app/config.ini for everyone</span>
<span class="na">BASE_PLUGINS</span> <span class="o">=</span> <span class="s">foo,bar</span>

<span class="c1"># ~/.config/app/config.ini that a user overrides based on the template</span>
<span class="na">EXTRA_PLUGINS</span> <span class="o">=</span> <span class="s">baz</span>
</pre></div>


<p>This way the only thing that changes is pure configuration variables, but the
same configuration code gets executed everywhere. We also were able to separate
configuration from code, which gives us some nice features:</p>
<ol>
<li>Ship configuration separately from code. There is no need to modify code in
   order to change it's behavior.</li>
<li>Plain text files are <em>universal</em>. Can be edited with any text editor, no
   need to mess with db connectors/sql/scripts to configure an app.</li>
<li>No need to know a programming language to configure the app. <a href="https://www.vagrantup.com/docs/vagrantfile/" title="Vagrantfile">Vagrant</a>,
   for example, uses Ruby for it's <code>Vagrantfile</code>, it is a bummer to have to
   learn the syntax of a language just to use a tool.</li>
<li>Since config files are not executable, they can partially override other
   config files in a line of hierarchy, as opposed to <code>.vimrc</code> files for
   example, that are executable and have to be <em>forked</em> to be adapted and a
   base config cannot be shared for all users in the system).</li>
</ol>
<p>The example of configuring plugins is not accidental. The idea is to show that
if you need to enable the user to do some scripting as customization, do so
through a plugin system, but never through scriptable config files.</p>
<h3 id="the-settingstemplate-trick">The <code>settings.template</code> trick<a class="headerlink" href="#the-settingstemplate-trick" title="Permanent link">&para;</a></h3>
<p>We still need a way to bundle settings for different environments: QA, stating,
production, test, Bill's dev machine, etc</p>
<p>Also, a litmus test for whether an app has all config correctly factored out of
the code is whether the codebase could be made open source at any moment,
without compromising any credentials. What this means is that credentials and
secrets should also be kept outside the codebase and made configurable.</p>
<p>So secrets and environment dependant settings have to be handled somehow.</p>
<p>Config files are very convenient since they can be version-controlled, can be
put into templates by Config Management/Orchestration tools and come handy when
developing.</p>
<p>Following the example above, a <code>config.ini.template</code> could look like this:</p>
<div class="highlight"><pre><span></span><span class="c1"># config.ini.template that each environment can implement</span>
<span class="c1"># EXTRA_PLUGINS = one_plugin,another_plugin</span>
<span class="c1"># SECRET_KEY = &lt;change me&gt;</span>
</pre></div>


<p>Even env vars can be put into a file (typically named <code>.env</code>) that gets loaded
before the program starts. Many tools that manage processes/containers, like
<a href="https://docs.docker.com/compose/env-file/" title="Declare default environment variables in file">docker-compose</a> and <a href="https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html" title="Using environment variables in systemd units">systemd</a>, or even <a href="https://github.com/theskumar/python-dotenv" title="python-dotenv">libraries</a> have support for
loading them.</p>
<p>It is common practice to put an example <code>settings.template</code> file that is in the
VCS, and then provide a way to copy + populate that template to a name that is
excluded by your VCS so that we never accidentally commit that. These files
might also be tracked by VCS, but encrypted, like it is done with <a href="https://docs.ansible.com/ansible/2.4/vault.html" title="Ansible Vault">Ansible
Vault</a>.</p>
<h3 id="devops-tools">Devops tools<a class="headerlink" href="#devops-tools" title="Permanent link">&para;</a></h3>
<p>Code needs to be <a href="https://12factor.net/build-release-run" title="The twelve-factor app | build, release, run">packaged, distributed, installed, executed</a>.</p>
<p>These are all steps that make use of external tools that are not part of the
codebase and should be replaceable. An app could be packaged for Ubuntu or
Windows differently, can be installed manually or put in a container. For this
reason, code should be as agnostic of these steps as possible and delegate that
to another actor called: <em>Installer/Builder</em>.</p>
<p>This new actor can be one or many tools combined, for example <code>docker-compose</code>,
<code>yum</code>, <code>gcc</code>, <code>ansible</code>, etc.</p>
<p>The installer actor is the one that knows how to bind code with the right
configuration it needs and how to do it (through env vars or files or cli args
or all of them). Because it knows the configuration it needs to inject into the
project, it makes a good candidate to manage  configuration templates for
files, vars that will be injected into the environment, or how to keep
secret/sensitive information protected.</p>
<p>The development and operations flow has two clearly distinct realms:</p>
<div class="highlight"><pre><span></span>+-------+           +-------+          +--------+         +-------+         +-------+
|       |           |       |          |        |         |       |         |       |
| code  +----------&gt;| build +---------&gt;|        |&lt;--------+service|&lt;--------+ conf  +
|       |           |       |          |        |         |       |         |       |
+-------+           +-------+          |        |         +-------+         +-------+
                                       |        |
                    +-------+          |        |         +-------+         +-------+
                    |       |          |        |         |       |         |       |
                    | conf  +---------&gt;|release |&lt;--------+service|&lt;--------+ conf  +
                    |       |          |        |         |       |         |       |
                    +-------+          |        |         +-------+         +-------+
                                       |        |
                    +-------+          |        |         +-------+         +-------+
                    |       |          |        |         |       |         |       |
                    | deps  +---------&gt;|        |&lt;--------+service|&lt;--------+ conf  +
                    |       |          |        |         |       |         |       |
                    +-------+          +--------+         +-------          +-------+

+-------------------+---------------------------------------------------------------+
|    code realm     |                   Devops/CM/Orchestraion realm                |
+-------------------+---------------------------------------------------------------+
</pre></div>


<p>If you use different tools when developing and when deploying, all these
scripts and templates will start to increase in number. When that moment comes,
there will be the temptation to delegate all this responsibility to the app to
"auto-configure and install itself".</p>
<p>Sometimes an app not only needs to be configured, but it might need <a href="https://12factor.net/backing-services" title="The twelve-factor app | backing services">other
services to be running</a>, so you'll have to replace an orchestration tool and
a supervisor. This basically means that you will be replacing specialized tools
with battle-tested ready-made solutions with your own implementation. More
code, mode problems.</p>
<p>The important thing to note here is that the application's code should not
install dependencies or start services or export variables to the environment
because an external service needs them.</p>
<p>Ideally, a project should support <a href="https://12factor.net/dev-prod-parity" title="The twelve-factor app | dev/prod parity">one set of build tools</a> and use it for
development and production. For example: docker everywhere.</p>
<h3 id="managing-config-changes">Managing config changes<a class="headerlink" href="#managing-config-changes" title="Permanent link">&para;</a></h3>
<p>The <a href="https://en.wikipedia.org/wiki/Signal_(IPC)#SIGHUP" title="Posix signals">SIGHUP signal</a> is usually used to trigger a reload of configurations
for daemons.</p>
<p>In Python, this can be achieved with the <code>signal</code> module, as the following gist shows:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">get_config</span><span class="p">(</span><span class="n">rel</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">config</span>
    <span class="k">if</span> <span class="n">rel</span><span class="p">:</span>
        <span class="nb">reload</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">config</span>

<span class="n">running</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="c1"># do something with get_config().foo</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># teardown</span>

<span class="k">def</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="c1"># Use kill -15 &lt;pid&gt;</span>
    <span class="k">if</span> <span class="n">signum</span> <span class="o">==</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">:</span>
        <span class="k">global</span> <span class="n">running</span>
        <span class="n">running</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># terminate daemon</span>

    <span class="c1"># kill -1 &lt;pid&gt;</span>
    <span class="k">elif</span> <span class="n">signum</span> <span class="o">==</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGHUP</span><span class="p">:</span>
        <span class="n">get_config</span><span class="p">(</span><span class="n">rel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># reload config</span>


<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">)</span>
<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">run</span><span class="p">()</span>
</pre></div>


<p>Then, the program can be notified about new config by using <code>kill -1</code> or: </p>
<div class="highlight"><pre><span></span>$ sudo systemctl reload application.service
</pre></div>


<p>If the app is part of a distributed cloud system, the same principle can still
be used. For example, Consul, a tool for service and configuration discovery
provides <code>consult-template</code>, a command to populate values from Consul into
automatically <a href="https://vimeo.com/109626825" title="Consul template demo">updated templates</a> that can emit reload commands to programs
to pick it up.</p>
<div class="highlight"><pre><span></span>$ consul-template <span class="se">\</span>
    -template <span class="s2">&quot;/tmp/nginx.ctmpl:/var/nginx/nginx.conf:nginx -s reload&quot;</span> <span class="se">\</span>
    -template <span class="s2">&quot;/tmp/redis.ctmpl:/var/redis/redis.conf:service redis restart&quot;</span> <span class="se">\</span>
    -template <span class="s2">&quot;/tmp/haproxy.ctmpl:/var/haproxy/haproxy.conf&quot;</span>
</pre></div>


<h2 id="conclusions">Conclusions<a class="headerlink" href="#conclusions" title="Permanent link">&para;</a></h2>
<p>Don't take responsibility of gathering configuration when developing a library.</p>
<p>In your app, always use a single <code>config.py</code> file that gathers all settings and
load it before starting the program. Use <a href="https://github.com/osantana/prettyconf" title="Prettyconf">prettyconf</a> since it follows the
settings discovery architecture for projects that we've shown, <a href="https://github.com/osantana/prettyconf/issues/18)">or will
soon</a>.</p>
<p>Keep in mind what belongs to which realm when writing code/scripts. Everything
can live in the same repo, but at least they will be in different folders
(<code>src/</code> and <code>ops/</code>, for example). Configuration for each service should be
handled separately, do not use a single <code>config.py</code> to configure Nginx and
Postgres for instance.</p>
<p>Consolidate a very similar set of tools for dev and production envs.
Containers are gaining popularity everywhere, use something like <a href="https://www.docker.com/" title="Docker">docker</a>
or <a href="https://github.com/ansible/ansible-container" title="Ansible Container">ansible-container</a> for both realms.</p>
</article>

      <footer class="column-right light">
        <nav><a href="/">Home</a> - <a href="/archives.html">Archives</a> - <a href="/categories.html">Categories</a> - <a href="/tags.html">Tags</a> - <a href="/rss.xml">RSS</a> - <a href="https://creativecommons.org/licenses/by/4.0/">License</a> | README.txt</nav>
      </footer>
  </main>
</body>
</html>